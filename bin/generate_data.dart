import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:ansicolor/ansicolor.dart';
import 'package:args/args.dart';
import 'package:dart2js_info_utils/data.dart';
import 'package:meta/meta.dart';
import 'package:pub_semver/pub_semver.dart';
import 'package:yaml/yaml.dart';

const String dart2jsInfoDartEntrypointArg = 'built-dir';
const String dart2jsInfoMinifyDart2JsOutputFlag = 'minify';
const String dart2jsInfoGenerateFlag = 'regenerate';

main(List<String> args) async {
  var parser = new ArgParser()
    ..addFlag('help', abbr: 'h', help: 'Print help.')
    ..addOption(dart2jsInfoDartEntrypointArg,
        help: 'The `.dart` entrypoint file.',
        defaultsTo: 'web/main.dart',
    )
    ..addFlag(dart2jsInfoMinifyDart2JsOutputFlag,
        help: 'Whether to minify the dart2js output.',
        negatable: true,
        defaultsTo: true,
    );

  try {
    var argValues = parser.parse(args);

    if (argValues['help']) {
      print('Utilities to parse, distill and visualize data generated by the dart2js_info package.\n');
      print(parser.usage);
      return;
    }

    new Dart2JsInfoUtils(argValues: argValues);
  } on FormatException {
    print(parser.usage);
    exit(-1);
  }
}

class Dart2JsInfoUtils {
  final ArgResults argValues;

  Dart2JsInfoUtils({@required this.argValues}) { initialize(); }

  Future<Null> initialize() async {
    this._exitCode = 0;

    await _buildPackage();
    await _generateDart2JsInfoData();

    _generateDataMapViews();
    await _copyStatics();
  }

  int get exitCode => _exitCode;
  int _exitCode;

  bool get regenerateDart2JsInfoData => argValues[dart2jsInfoGenerateFlag];
  String get packageName {
    YamlMap pubspec = loadYamlDocument(File('pubspec.yaml').readAsStringSync()).contents;
    return pubspec['name'];
  }
  String get dartEntrypoint => argValues[dart2jsInfoDartEntrypointArg];
  String get jsFile => '${Directory.current.path}/.dart_tool/build/generated/$packageName/$dartEntrypoint.js';
  String get jsInfoJsonFile => '$jsFile.info.json';
  String get dart2JsInfoOutputDir => dart2jsInfoPath;
  String get dart2JsInfoDataOutputDir => '$dart2JsInfoOutputDir/$dart2JsInfoOutputSubDir';
  String get dart2JsInfoUtilMapViewDataOutputDir => '$dart2JsInfoDataOutputDir/$dart2JsInfoUtilMapViewDataOutputSubDir';

  // ----------------------------------------------------
  //  Helper Methods
  // ----------------------------------------------------

  /// Runs dart2js_info_[cmd] and writes the [ProcessResult.stdout] to a file at [outFilePath].
  Future<Null> _runDart2JsInfoCmd(String cmd, String outFilePath) async {
    var file = new File(outFilePath);
    if (!file.existsSync()) {
      file.createSync(recursive: true);
    }

    final processArgs = [cmd, jsInfoJsonFile];
    print('Running `dart2js_info ${processArgs.join(' ')}...');
    final process = await Process.start('dart2js_info', processArgs);

    final stdout = <String>[];
    final stdoutSub = process.stdout.transform(utf8.decoder).transform(const LineSplitter()).listen((line) {
      stdout.add(line);
    });
    final stderrSub = process.stderr.transform(utf8.decoder).transform(const LineSplitter()).listen(print);

    await process.exitCode.then((code) {
      stdoutSub.cancel();
      stderrSub.cancel();

      if (code != 0) {
        exit(code);
      } else {
        var stdOutString = stdout.join('\n');
        if (cmd == 'deferred_layout') {
          stdOutString = stdOutString.replaceFirst('loaded by default', 'loaded by:');
        }

        file.writeAsStringSync(stdOutString);
        print('Successfully ran `dart2js_info $cmd` and wrote the result to `$outFilePath`.');
      }
    });
  }

  // ----------------------------------------------------
  //  Core Process Methods
  // ----------------------------------------------------

  Future<Null> _buildPackage() async {
    final minifyStr = argValues['minify'] ? 'minify' : 'no-minify';
    final pbrArgs = ['run', 'build_runner', 'build', '--define', 'build_web_compilers|entrypoint=dart2js_args=["--$minifyStr", "--dump-info"]'];
    print('Running `pub ${pbrArgs.join(' ')}... (Grab a Snickers)');
    final pbrProcess = await Process.start(
      'pub',
      pbrArgs,
      mode: ProcessStartMode.inheritStdio,
    );
    await pbrProcess.exitCode.then((code) {
      if (code != 0) {
        exit(code);
      }
    });
  }

  Future<Null> _generateDart2JsInfoData() async {
    await globallyActivatePackage('dart2js_info');

    print('Generating information about $jsFile...');

    await _runDart2JsInfoCmd('library_size', '$dart2JsInfoDataOutputDir/$dart2JsInfoLibSizeSplitOutFileName');
    await _runDart2JsInfoCmd('deferred_layout', '$dart2JsInfoDataOutputDir/$dart2JsInfoDeferredLibLayoutOutFileName');
  }

  /// Constructs [DeferredLibraryLayoutView]s using the data generated by the
  /// `dart2js_info` package (via [_generateDart2JsInfoData]) and writes raw Dart [Map]s
  /// to files within [dart2JsInfoUtilMapViewDataOutputDir].
  void _generateDataMapViews() {
    print('Mapping Raw Data Generated By `dart2js_info`...');

    var jsFileName = new RegExp(r'\/(\w+)(?:\.dart\.js)').firstMatch(jsFile).group(1);

    final deferredLibraryLayoutSrc = loadYamlDocument(File('$dart2JsInfoDataOutputDir/$dart2JsInfoDeferredLibLayoutOutFileName').readAsStringSync());
    final entitySizeListSrc = File('$dart2JsInfoDataOutputDir/$dart2JsInfoLibSizeSplitOutFileName').readAsLinesSync();

    try {
      final view = new DeferredLibraryLayoutView.groupByPackage(
          jsFileName: jsFileName,
          dart2JsInfoOutputDir: dart2JsInfoDataOutputDir,
          dart2JsInfoUtilMapViewDataOutputDir: dart2JsInfoUtilMapViewDataOutputDir,
          deferredLibraryLayoutSrc: deferredLibraryLayoutSrc,
          entitySizeListSrc: entitySizeListSrc,
      );
      createViewFile(view);
    } catch (err, stackTrace) {
      print(err);
      print(stackTrace);

      exit(-1);
    }

    try {
      final view = new DeferredLibraryLayoutView.groupByPart(
          jsFileName: jsFileName,
          dart2JsInfoOutputDir: dart2JsInfoDataOutputDir,
          dart2JsInfoUtilMapViewDataOutputDir: dart2JsInfoUtilMapViewDataOutputDir,
          deferredLibraryLayoutSrc: deferredLibraryLayoutSrc,
          entitySizeListSrc: entitySizeListSrc,
      );
      createViewFile(view);
    } catch (err, stackTrace) {
      print(err);
      print(stackTrace);

      exit(-1);
    }
  }

  Future<Null> _copyStatics() async {
    print('Copying Web Interface Static Files...');
    final String sep = Platform.pathSeparator;

    var utilsPath = new File('.packages')
        .readAsLinesSync()
        .firstWhere((line) => line.startsWith('dart2js_info_utils'))
        // Lines are of the form <package>:<path>,
        // "dart2js_info_utils:" so we skip the
        // package name characters to isolate the path.
        .substring('dart2js_info_utils'.length + 1)
        // Strip leading protocol
        .replaceFirst('file://', '')
        // Strip trailing path separators
        .replaceFirst(new RegExp('$sep\$'), '');

    var pathToStatics = '$utilsPath${sep}src${sep}statics';
    final copyStaticsProcess = await Process.start('cp', ['-r', '$pathToStatics/.', '$dart2JsInfoOutputDir/'], mode: ProcessStartMode.inheritStdio);

    await copyStaticsProcess.exitCode.then((code) {
      if (code != 0) {
        exit(0);
      }
    });

    // ignore: avoid_as
    final importInstructionsPath = dart2JsInfoUtilMapViewDataOutputDir.replaceFirst('./', '');

    print('''
All done!

You can now explore the data in your browser at localhost:8080 by running

    `pub run dart2js_info_utils:view_data`

Or access it as a raw Dart map by importing it:

    ```
    import 'package:dart2js_info_utils/data.dart';
    
    // ignore: uri_does_not_exist
    import '$importInstructionsPath/$dart2JsInfoUtilMapViewByPackageFile' as data_by_package;
    // ignore: uri_does_not_exist 
    import '$importInstructionsPath/$dart2JsInfoUtilMapViewByPartFile' as data_by_part;
    
    
    var byPackageRawData = data_by_package.deferredLibraryLayoutByPackage;
    var byPartRawData = data_by_part.deferredLibraryLayoutByPart;
    
    // Use MapViews for typed access to the raw data!
    var byPackageMapView = new DeferredLibraryLayoutByPackageMapView(byPackageRawData);
    var byPartMapView = new DeferredLibraryLayoutByPartMapView(byPartRawData);
    ```
    ''');

    exit(0);
  }
}

void createViewFile(DeferredLibraryLayoutView view) {
  var file = new File(view.outFile);

  if (!file.existsSync()) {
    file.createSync(recursive: true);
  }

  file.writeAsStringSync(view.toFileString());
}

Map<String/*name*/, Version> globallyActivatedPackagesCache;
Future<Map<String/*name*/, Version>> getGloballyActivatedPackages() async {
  if (globallyActivatedPackagesCache != null) return globallyActivatedPackagesCache;

  List<String> listGloballyActivatedPackagesCommand = [
    'pub',
    'global',
    'list',
  ];

  final listGloballyActivatedPackages =
      await Process.start(listGloballyActivatedPackagesCommand.first, listGloballyActivatedPackagesCommand.sublist(1));

  globallyActivatedPackagesCache = <String, Version>{};
  listGloballyActivatedPackages.stdout.transform(utf8.decoder).transform(const LineSplitter()).listen((line) {
    final packageNameAndVersion = line.split(' ');
    globallyActivatedPackagesCache[packageNameAndVersion[0]] = new Version.parse(packageNameAndVersion[1]);
  });

  await listGloballyActivatedPackages.exitCode.then((code) {
    if (code != 0) {
      throw new ProcessException(
          'pub global list',
          [],
          'Error occurred while trying to get a list of the globally activated pub packages.',
          code);
    }
  });

  return globallyActivatedPackagesCache;
}

Future<Null> globallyActivatePackage(String packageName,
    [Map<String, Version> minimumPackageVersionMeta = const <String, Version>{}]) async {
  final globallyActivatedPackages = await getGloballyActivatedPackages();
  bool packageIsActivated = globallyActivatedPackages?.keys?.contains(packageName) == true;
  if (!minimumPackageVersionMeta.containsKey(packageName) && packageIsActivated) return;

  if (packageIsActivated) {
    final activatedVersion = globallyActivatedPackages[packageName];
    if (activatedVersion < minimumPackageVersionMeta[packageName]) {
      print(color(new AnsiPen()..yellow(),
          'Your globally activated version of the $packageName package ($activatedVersion) is not '
          'compatible with this version of Storybook. \n\nUpgrading now...'));

      List<String> deactivateCommand = [
        'pub',
        'global',
        'deactivate',
        packageName,
      ];

      final deactivate = await Process.start(deactivateCommand.first, deactivateCommand.sublist(1));

      deactivate
        ..stdout.transform(utf8.decoder).transform(const LineSplitter()).listen(print)
        ..stderr.transform(utf8.decoder).transform(const LineSplitter()).listen(print);

      await deactivate.exitCode;
      print('Reactivating the $packageName package...');
    } else {
      return;
    }
  } else {
    print('Activating the $packageName package...');
  }

  final activateCommand = [
    'pub',
    'global',
    'activate',
    packageName,
  ];

  if (minimumPackageVersionMeta.containsKey(packageName)) {
    activateCommand.add('^${minimumPackageVersionMeta[packageName]}');
  }

  final activate = await Process.start(activateCommand.first, activateCommand.sublist(1));

  activate.stdout.transform(utf8.decoder).transform(const LineSplitter()).listen((line) {
    if (line.contains('Activated $packageName')) {
      print(color(new AnsiPen()..green(), line));
    }
  });
  activate.stderr.transform(utf8.decoder).transform(const LineSplitter()).listen(print);

  await activate.exitCode.then((code) {
    if (code != 0) {
      throw new ProcessException(
          activateCommand.join(' '),
          [],
          'Error occurred while activating the $packageName package.',
          code);
    }
  });
}

String color(AnsiPen pen, String message) => pen(message);

